const e='{"documentCount":8,"nextId":8,"documentIds":{"0":"/front-cheese-store/components/button.html#按钮","1":"/front-cheese-store/components/icon.html#图标","2":"/front-cheese-store/interview/vue/v-model的作用.html#v-model的作用","3":"/front-cheese-store/interview/vue/v-model的作用.html#扩展","4":"/front-cheese-store/interview/vue/v-model的实现原理.html#v-model的实现原理","5":"/front-cheese-store/interview/vue/vue3实现数据双向绑定的方法.html#vue3-0-实现数据双向绑定的方法","6":"/front-cheese-store/interview/vue/vue2数据双向绑定的缺陷.html#vue2-0-双向绑定的缺陷","7":"/front-cheese-store/interview/vue/路由懒加载.html#路由懒加载"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,1],"2":[2,1,18],"3":[2,2,14],"4":[2,1,32],"5":[3,1,41],"6":[4,1,101],"7":[1,1,52]},"averageFieldLength":[2,1.125,32.5],"storedFields":{"0":{"title":"按钮","titles":[]},"1":{"title":"图标","titles":[]},"2":{"title":"v-model的作用","titles":[]},"3":{"title":"扩展：","titles":["v-model的作用"]},"4":{"title":"v-model的实现原理","titles":[]},"5":{"title":"Vue3.0 实现数据双向绑定的方法","titles":[]},"6":{"title":"Vue2.0 双向绑定的缺陷？","titles":[]},"7":{"title":"路由懒加载","titles":[]}},"dirtCount":0,"index":[["new",{"2":{"7":1}}],["newvalue",{"2":{"6":1}}],["只需要像往常一样使用foo",{"2":{"7":1}}],["只能追踪到数据是否被修改",{"2":{"6":1}}],["自动代码分割的异步组件",{"2":{"7":1}}],["自html5开始",{"2":{"4":1}}],["返回",{"2":{"7":1}}],["我们可以使用动态",{"2":{"7":1}}],["中",{"2":{"7":1}}],["中新增的一个特性",{"2":{"5":1}}],["组件定义对象",{"2":{"7":1}}],["组件本身",{"2":{"7":1}}],["应该",{"2":{"7":1}}],["该函数返回的",{"2":{"7":1}}],["首先",{"2":{"7":1}}],["webpack",{"2":{"7":3}}],["的工厂函数",{"2":{"7":1}}],["的代码分割功能",{"2":{"7":1}}],["的异步组件和",{"2":{"7":1}}],["的核心优点是可以交由它来处理一些非核心逻辑",{"2":{"5":1}}],["结合这两者",{"2":{"7":1}}],["结合",{"2":{"7":1}}],["然后当路由被访问的时候才加载对应组件",{"2":{"7":1}}],["影响页面加载",{"2":{"7":1}}],["包会变得非常大",{"2":{"7":1}}],["当打包构建应用时",{"2":{"7":1}}],["当创建一个vue实例时",{"2":{"6":1}}],["懒加载",{"2":{"7":1}}],["路由懒加载",{"0":{"7":1}}],["对象的响应式实现",{"2":{"6":1}}],["改变传入数组的prototype",{"2":{"6":1}}],["改变get和set",{"2":{"6":1}}],["数组实现响应式",{"2":{"6":1}}],["observe",{"2":{"6":1}}],["obj",{"2":{"6":5}}],["object",{"2":{"6":3}}],["视图更新",{"2":{"6":1}}],["arguments",{"2":{"6":1}}],["array",{"2":{"6":3}}],["重写proto中的数组方法",{"2":{"6":1}}],["foo",{"2":{"7":6}}],["foreach",{"2":{"6":1}}],["function",{"2":{"6":2}}],["component",{"2":{"7":1}}],["call",{"2":{"6":1}}],["create",{"2":{"6":1}}],["checkbox",{"2":{"3":1}}],["checked",{"2":{"2":1}}],["复制array",{"2":{"6":1}}],["method",{"2":{"6":3}}],["methods",{"2":{"6":2}}],["model=",{"2":{"4":1}}],["model只不过是一个语法糖而已",{"2":{"4":1}}],["model的实现原理",{"0":{"4":1}}],["model的作用",{"0":{"2":1},"1":{"3":1}}],["model在内部为不同的输入元素使用不同的属性并抛出不同的事件",{"2":{"3":1}}],["model会忽略所有表单元素的value",{"2":{"2":1}}],["model",{"2":{"2":1}}],["model本质上不过是语法糖",{"2":{"2":1}}],["具体来说就是重新指定要操作数组的prototype",{"2":{"6":1}}],["通过下面代码简单了解下实现原理",{"2":{"6":1}}],["通过重写数组的array",{"2":{"6":1}}],["通过object",{"2":{"6":1}}],["let",{"2":{"6":1}}],["length",{"2":{"6":1}}],["location",{"2":{"6":2}}],["import",{"2":{"7":1}}],["import语法来定义代码分块点",{"2":{"7":1}}],["isarray",{"2":{"6":1}}],["if",{"2":{"6":2}}],["items",{"2":{"6":2}}],["index",{"2":{"6":2}}],["input方法中",{"2":{"4":1}}],["input每次输入都会触发oninput事件",{"2":{"4":1}}],["input=",{"2":{"4":1}}],["input",{"2":{"4":2}}],["例如如下两种使用方式",{"2":{"6":1}}],["其他数组方法及数组的使用则无法检测到",{"2":{"6":1}}],["其功能非常类似于设计模式中的代理模式",{"2":{"5":1}}],["routes",{"2":{"7":1}}],["router",{"2":{"7":1}}],["resolve",{"2":{"7":2}}],["return",{"2":{"6":1}}],["reverse",{"2":{"6":1}}],["reverse七个方法",{"2":{"6":1}}],["radio",{"2":{"3":1}}],["unshift",{"2":{"6":2}}],["path",{"2":{"7":1}}],["point",{"2":{"7":1}}],["pop",{"2":{"6":2}}],["push",{"2":{"6":1}}],["promise",{"2":{"7":4}}],["proto",{"2":{"6":4}}],["prototype",{"2":{"6":4}}],["prototype对应的方法",{"2":{"6":1}}],["proxy",{"2":{"5":3}}],["proxy是",{"2":{"5":1}}],["propertname",{"2":{"6":1}}],["prop",{"2":{"3":1}}],["这就是如何定义一个能够被",{"2":{"7":1}}],["这样就更加高效了",{"2":{"7":1}}],["这也只限制在数组的push",{"2":{"6":1}}],["这个属性不会被vue处理",{"2":{"6":1}}],["把无法监听数组的情况通过重写数组的部分方法来实现响应式",{"2":{"6":1}}],["不能监听数组的变化",{"2":{"6":1}}],["2",{"2":{"6":1,"7":1}}],["z",{"2":{"6":1}}],["y",{"2":{"6":1}}],["x",{"2":{"6":1}}],["x3c",{"2":{"4":9}}],["data",{"2":{"6":3}}],["defineproperty只能劫持对象的属性",{"2":{"6":1}}],["defineproperty",{"2":{"5":1,"6":1}}],["响应式对象的子对象新增属性",{"2":{"6":1}}],["jsimport",{"2":{"7":1}}],["jsconst",{"2":{"6":1,"7":3}}],["jsvm",{"2":{"6":1}}],["jsvue",{"2":{"6":1}}],["javascript",{"2":{"2":1,"7":1}}],["解决方案",{"2":{"6":1}}],["一个属性",{"2":{"6":1}}],["或删除",{"2":{"6":1}}],["但是",{"2":{"6":1}}],["但是它并不算是实现数据的响应式的完美方案",{"2":{"6":1}}],["允许vue观察数据的更改并触发更新",{"2":{"6":1}}],["get和set",{"2":{"6":1}}],["getter",{"2":{"6":1}}],["将遍历所有dom对象",{"2":{"6":1}}],["无法检测到对象属性的新增或删除",{"2":{"6":1}}],["100",{"2":{"6":3}}],["1",{"2":{"6":1}}],["主要表现在两个方面",{"2":{"6":1}}],["来劫持各个属性的setter",{"2":{"6":1}}],["订阅者模式的方式",{"2":{"6":1}}],["双向绑定的缺陷",{"0":{"6":1}}],["双向数据绑定",{"2":{"5":1}}],["优势",{"2":{"5":1}}],["相比2",{"2":{"5":1}}],["降低对象复杂度等目的",{"2":{"5":1}}],["达到关注点分离",{"2":{"5":1}}],["从而可以让对象只需关注于核心逻辑",{"2":{"5":1}}],["某些情况下需要对其进行修补或者hack这也是它的缺陷",{"2":{"6":1}}],["某些属性的访问控制等",{"2":{"5":1}}],["某些操作",{"2":{"5":1}}],["需要验证",{"2":{"5":1}}],["设置对象的某些属性值前",{"2":{"5":1}}],["读取或设置对象的某些属性前记录日志",{"2":{"5":1}}],["如果我们能把不同路由对应的组件分割成不同的代码块",{"2":{"7":1}}],["如果你在vue实例化后添加",{"2":{"6":1}}],["如",{"2":{"5":1}}],["使用proxy实现",{"2":{"5":1}}],["使用",{"2":{"5":1}}],["使用checked属性和change事件",{"2":{"3":1}}],["因此提供了一种机制",{"2":{"5":1}}],["因此我们应该通过",{"2":{"2":1}}],["都必须先通过这层拦截",{"2":{"5":1}}],["外界对该对象的访问",{"2":{"5":1}}],["拦截",{"2":{"5":1}}],["可以将异步组件定义为返回一个",{"2":{"7":1}}],["可以实现路由组件的懒加载",{"2":{"7":1}}],["可以给子响应式对象重新赋值",{"2":{"6":1}}],["可以劫持整个对象",{"2":{"5":1}}],["可以对外界的访问进行过滤和改写",{"2":{"5":1}}],["可以理解成",{"2":{"5":1}}],["可以用",{"2":{"2":1}}],["让我们能够以简洁易懂的方式控制外部对对象的访问",{"2":{"5":1}}],["用在这里表示由它来",{"2":{"5":1}}],["代理",{"2":{"5":2}}],["quot",{"2":{"5":2}}],["翻译过来意思是",{"2":{"5":1}}],["es6",{"2":{"5":1}}],["实现",{"2":{"7":1}}],["实现数据双向绑定是通过proxy",{"2":{"5":1}}],["实现数据双向绑定的方法",{"0":{"5":1}}],["实例创建后",{"2":{"6":1}}],["实例的数据作为数据来源",{"2":{"2":1}}],["0的数据响应是采用数据劫持结合发布者",{"2":{"6":1}}],["0的object",{"2":{"5":1}}],["0",{"0":{"5":1,"6":1},"2":{"5":1}}],["在路由配置中什么都不需要改变",{"2":{"7":1}}],["在目标对象之前架设一层",{"2":{"5":1}}],["在",{"2":{"4":2,"7":1}}],["在组件的data选项中声明初始值",{"2":{"2":1}}],["就是当前dom的value值",{"2":{"4":1}}],["指代当前触发的事件对象的dom",{"2":{"4":1}}],["指代当前触发的事件对象",{"2":{"4":1}}],["指令在表单及元素上创建双向数据绑定",{"2":{"2":1}}],["于是sth的值就被改变",{"2":{"4":1}}],["所以输入时input的内容会绑定到sth中",{"2":{"4":1}}],["typeof",{"2":{"6":1}}],["this",{"2":{"6":1}}],["target",{"2":{"4":3}}],["textarea",{"2":{"3":1}}],["text",{"2":{"3":1}}],["$event",{"2":{"4":4}}],["===",{"2":{"6":1}}],["=>",{"2":{"4":2,"6":1,"7":2}}],["=",{"2":{"4":1,"6":7,"7":3}}],["等同于",{"2":{"4":1}}],[">",{"2":{"4":9}}],["split",{"2":{"7":1}}],["splice",{"2":{"6":2}}],["sort",{"2":{"6":2}}],["shift",{"2":{"6":2}}],["set",{"2":{"6":1}}],["select",{"2":{"3":1}}],["selected特性的初始值",{"2":{"2":1}}],["sth",{"2":{"4":5}}],["html",{"2":{"4":1}}],["事件并传递数据",{"2":{"4":1}}],["触发oninput",{"2":{"4":1}}],["绑定响应式数据",{"2":{"4":1}}],["bind",{"2":{"4":1}}],["真正的实现靠的还是",{"2":{"4":1}}],["并将其prototype指向array",{"2":{"6":1}}],["并将change作为事件",{"2":{"3":1}}],["并重新该prototype中对应上面的7个数组方法",{"2":{"6":1}}],["并为每个数据属性添加了get和set",{"2":{"6":1}}],["并返回一个新对象且有13种劫持操作",{"2":{"5":1}}],["并对一些极端场景进行一些特殊处理",{"2":{"2":1}}],["字段将value作为",{"2":{"3":1}}],["元素使用value属性和input事件",{"2":{"3":1}}],["和",{"2":{"3":2}}],["扩展",{"0":{"3":1},"2":{"5":1}}],["而总是将",{"2":{"2":1}}],["它使用了一些hack",{"2":{"6":1}}],["它负责监听用户的输入事件以更新数据",{"2":{"2":1}}],["它会根据控件类型自动选取正确的方法来更新元素",{"2":{"2":1}}],["viewrender",{"2":{"6":1}}],["vm",{"2":{"6":1}}],["value中",{"2":{"4":1}}],["value",{"2":{"4":4,"6":1}}],["value=",{"2":{"4":1}}],["vuerouter",{"2":{"7":1}}],["vue实现数组响应式的方法",{"2":{"6":1}}],["vue在实现数组的响应式时",{"2":{"6":1}}],["vue2",{"0":{"6":1},"2":{"6":1}}],["vue3",{"0":{"5":1},"2":{"5":1}}],["vue",{"2":{"2":1,"6":1,"7":3}}],["v",{"0":{"2":1,"4":1},"1":{"3":1},"2":{"2":3,"3":1,"4":3}}],["图标",{"0":{"1":1}}],["按钮",{"0":{"0":1}}]],"serializationVersion":2}';export{e as default};
